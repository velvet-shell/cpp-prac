/*
нити отличаются только контекстом исполнения (различные параметры для планировщика)

в новом процессе после форка продолжит работать только одна нить, которая выполнялась на момент форка

если вы хотите убивать нити - значит вы что-то делаете не так, их надо просить

каждая нить имеет доступ к стеку любой другой нити

-fsanitize=thread для отлавливания ошибок (data race, etc)
*/

#include <thread>
#include <iostream>
#include <sstream>

void func(int a, double b, const std::string &str, int &val)
{
    //cout не синхронизирован
    //нужен костыль, чтобы синхронизировать вывод
    std::ostringstream oss;
    oss << a << "\n" << b << "\n" << str << "\n" << (void *) &str << "\n";
    std::cout << oss.str();
    val = 100;
}

int main(void)
{
    std::thread thr;

    std::string str{"a string"};
    int val = 0;

    //std::thread()
    //переменное число аргументов
    //первый аргумент сущность, допускающая круглые скобки. Нить работает, пока жива сущность.
    //вообще говоря, аргументы в функцию передаются через ядро

    //thr = std::thread(func, 10, 20.5, str);
    //передаче по ссылке не сработает, в итоге будет передача по значению


    thr = std::thread(func, 10, 20.5, std::ref(str), std::ref(val));
    //для передачи по ссылке использовать ref (замораживает ссылку на всем пути от аргумента, до функции)

    std::cout << val << "\n" << (void *) &str << "\n";
    //data race

    //join приостанавливает выполнение до завершения указанной нити
    //вызывать не более одного раза для одной нити, иначе UB
    thr.join();
    //альтернатива - detached режим
    //thr.detach();
    //в данном случае процесс может завершиться раньше нити и вывод func может быть утерян
    
    std::cout << val << "\n";
    //нет data race, так как выполнен join
}